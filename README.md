Probe
=========

Probe: systematic capture for dynamic program state

## Introduction

Text-based logging infrastructure is an unfortunate historical
artifact. A log statement serializes a small portion of dynamic
program state in a human-readable form. While these log strings are
trivial to store, route, manipulate, and inspect - they take much more
work to analyze and relate back to the context in which they were
produced.  

Modern systems are more than capable of “late binding” the conversion
of dynamic state from a native internal representation to a
human-readable format.  Instead, we can provide facilities for
processing streams of state generated by program at various 'probe
points' and use these traces for many other purposes such as
profiling, auditing, forensics, etc.  Rather than using Scribe or
Splunk, why not just write all of your state to a horizontally
scalable resource like HBase, MongoDB, Cassandra, DynamoDB, etc where
it can be indexed and used as needed?

Probe is a library that makes it easy to capture state both explicitly
and implicitly from Clojure and define one or more sinks to route it
to.  It provides a simple logging API compability layer supporting the
Pedestal logging interface.  Clojure.tools.logging compability coming
up.

An alternative and possibly richer (although more complex) approach is
[Lamina](https://github.com/ztellman/lamina), introduced in a [nice
talk](http://vimeo.com/45132054#!) that closely shares the philosophy
behind Probe.

## Concepts

* Probe statement - Any program statement that extracts dynamic state during
  program execution. A probe will typically return some subset of
  lexical, dynamic, and/or host information as well as explicit
  user-provided data.  Probes can include function
  entry/exit/exception events as well or tie into foundational notification
  mechanisms such as adding a 'watcher probe' to an agent or atom.
   * Function probe - Default probes that can be added to any Var holding a function value
   * Watcher probe - Probe state changes on any Atom, Ref, Var, or Agent.
* Probe state - A kv-map generated by a probe statement
* Tags - Probe expressions accept one or more tags to help filter and route state.
    Built-in probe statements generate a specific set of tags.
* Sink - A function that takes probe state values and disposes them in some
    way, typically to a logging subsystem, the console, memory or a database.
* Subscriptions - This is the library's glue, consisting of a Selector, an
    optional core.async Channel, and a sink name.
* Selector - a conjunction of tags that must be present for the probe state to 
    be pushed onto the channel and on to the sink.

Reserved state keys

- Probe statements: :thread-id, :tags, :ns, :line, :ts
- Expression probe: :expr, :value
- Function probes: :fname, :fn, :args, :return, :exception

Reserved tags:

- Namespace tags: :ns/*
- Function probes: :probe/fn, :probe/fn-exit, :probe/fn-enter, :probe/fn-except
- Watcher probes: :probe/watch
- Standard logging levels: :trace, :debug, :info, :warn, :error

## Documentation by Example

    (require '[probe.core :as p])
	(require '[probe.sink :as sink]
	(require '[core.async :as async])

Start with a simple console sink

	(p/add-sink :printer sink/console-raw)

Let's watch some test probe points:

    (p/subscribe #{:test} :printer)

	(p/probe [:test] :value 10)
	=> nil    
	{:ts #inst "2013-11-19T01:21:57.109-00:00", :thread-id 307, :ns probe.core, :tags #{:test :ns/probe.core :ns/probe}, :line 1, :value 10}

Probe state is only sent to the sink when the selector matches the
tags.  In fact, the entire probe expression is conditional on there
being at least one matching probe for the tags.

    (p/probe [:foo] :value 10)
	=> nil

We can use a core.async transform channel to watch just the values and timestamp:

    (p/subscribe #{:test} :printer
        (async/map> #(select-keys % [:ts :value]) (async/chan)))

    (p/probe #{:debug} :value 10)
	=> nil
    {:ts #inst "2013-11-19T01:25:37.348-00:00", :value 10}

What subscriptions do we have now?

	(p/subscriptions) 
	=> ([#{:test} :printer])

Notice that our update clobbered the prior subscription.  We can grab
the complete subscription or sink value to get a better sense of
internals:

    (p/get-subscription #{:test} :printer)
    => {:selector #{:test}, :channel #<async$map_GT_$reify__26869 clojure.core.async$map_GT_$reify__26869@f7503>, :sink :printer}

Here we see a selector which determines whether probes are submitted
at all, the channel to push the state to, and the sink that channel is
connected to.

    (p/get-sink :printer)
	=> {:name :printer, :function #<sink$console_raw probe.sink$console_raw@1ff3ef9>, :in #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@7f528f>, :mix #<async$mix$reify__27625 clojure.core.async$mix$reify__27625@105559f>, :out #<ManyToManyChannel clojure.core.async.impl.channels.ManyToManyChannel@13874b7>}

Sinks uses a core.async mix to accept inputs from multiple
subscriptions and pipes them to the sink handler function.  If you
want to do something for every state submitted to a sink, you can just
wrap the sink function when creating the sink.  For any short-term or
source specific transforms, use subscription transform channels.  For
transforms performed system wide, write your own macro that wraps the
main probe macro used above and injects whatever data you care about,
or have a standard way of generating application-specific transform
channels.

Core.async channels are composable, so you can compose a set of standard
mapping, filtering channels into what you need for a specific purpose.

Let's explore some other probing conveniences.  For example, good
functional code comes pre-packaged with some wonderful probe points
called functions.

    (def testprobe [a b]
	  (+ a b))

    (p/probe-fn! #{:test} 'testprobe)

	(testprobe 1 2)
    => 3

    (p/subscribe #{:test} :printer) ;; stomp on our earlier filter

	(testprobe 1 2)
  	=> 3
    {:ts #inst "2013-11-19T01:36:28.237-00:00", :thread-id 321, :ns probe.core, :tags #{:test :ns/probe.core :ns/probe :probe/fn-enter}, :args (1 2), :fn :enter, :line 1, :fname testprobe}
    {:ts #inst "2013-11-19T01:36:28.237-00:00", :thread-id 321, :ns probe.core, :tags #{:probe/fn-exit :test :ns/probe.core :ns/probe}, :return 3, :args (1 2), :fn :exit, :line 1, :fname testprobe}

We can now magically trace input arguments and return values for every
expression.  How about just focusing on the input/outputs?  We can use
some channel builders from the probe.core package to make this more concise.

;; ================================================

    (defn args-and-value [state] (select-keys state [:args :value :fname]))
    (p/subscribe #{:test :probe/fn-exit} :printer (p/map> args-and-value))

	(map #(testprobe 1 %) (repeat 0 10))
  	=> 3


This demonstrates generating test vectors from runtime for any
function simply by probing the function and appropriately filtering
the result.  

So far, we've just been printing stuff out.  Not much better than
playing with logs.  What if we want to capture some vectors from deep
inside a system for interactive replay at the repl?

    (def my-tests (atom nil))
	(sink/add-sink :accum (sink/memory-sink))
	(p/subscribe #{:test :probe/fn-exit} :accum (p/map> args-and-value))

	(map #(testprobe 1 %) (repeat 0 10))
    => (...)

    (sink/scan-memory)
    => 
    ({:args (1 5), :return 7, :fname testprobe} {:args (1 4), :return 6, :fname testprobe})

	(unprobe-fn! 'testprobe)

We can also watch state elements like Refs and Vars:

    (def myatom {:test 1})
    (probe-state! identity myatom)
    (set-config! 'user :state
      [sink/console-raw])

    (swap! myatom update-in [:test] inc)
    => {:test 2}
    => {:ts 1384410782190, :ns user, :test 2, :thread-id 457, :tags [:state]}

Of course a flood of maps could get overwhelming in a real system,
even if you just turn on this ability for a short while.  We can
capture a random sub-sample of the traced data:

    (p/set-config! 'user :exit-fn
	   '[(policy/random-sample 0.01)
         (select-keys [:fname :return :args]) 
         (sink/memory my-tests)])

We can used a fixed length in-memory queue to keep the last N items

    (def my-tests (sink/make-memory))
    (p/set-config! 'user :exit-fn
	   '[(policy/random-sample 0.01)
         (select-keys [:fname :return :args]) 
         (sink/fixed-memory my-tests 5)])

    (dotimes [i 10]
      (testprobe i 10))

    (clojure.pprint/pprint (seq @my-tests))
    => ({:args (5 10), :return 16, :fname testprobe} 
        {:args (7 10), :return 17, :fname testprobe} 
        {:args (8 10), :return 18, :fname testprobe} 
        {:args (9 10), :return 19, :fname testprobe} 
        {:args (10 10), :return 20, :fname testprobe})

We can also select for specific functions in the namespace:
        
    (p/set-config! 'user :exit-fn
	   '[(policy/select-fn testprobe)
         (select-keys [:fname :return :args]) 
         (sink/memory my-tests)])
    
Or only collect data when there are failures:

    (p/remove-config! 'user :exit-fn)
    (p/set-config! 'user :except-fn
	   '[(select-keys [:ts :fname :return :args])
         sink/console-raw])

    (reset! my-tests (sink/make-memory))

    (defn testprobe [a b] (if (= a 2) (throw (Exception. "oops")) (+ a b 1)))
    (testprobe 1 3)
    => 5
	(testprobe 2 3)
    {:args (2 3), :fname testprobe}
    ; Evaluation aborted.

Finally, what if you just want to write a log in the (almost) traditional way?

    (use '[probe.logging :as log])
    (log/error :msg "This is an error" :exception e :value 10)

This uses the Pedestal convention promoted by Relevance, but captures
the structured data before converting it to a string.  This statement
is equivalent to:

    (probe [:error] :msg "This is an error" :exception e :value 10)

except that the probe statement is only called if the underlying
logger for that namespace is active.

## Discussion

I moved to core.async in 0.9.0 because it provides a sound
infrastructure for assembling functions in topologies to operate over
streams of events.  I've picked a simple di-graph topology to keep
things simple for interactive use, but it would only take a little
extra code to support more complex topologies.

## Future Work

Here are some opportunities to improve the library.

### Future Tasks (Minor)

* Add higher level channel constructor support
* Add a clojure EDN file sink
* Record the stack state at a probe point 
* Add higher level targeted function tracing / collection facilities
  (e.g. trace 100 input/result vectors from function f or namespace ns)
* Add metadata so we can inspect what functions are probed

### Future Tasks (Major)

* Performance.  There are quite a few places where the performance of the probe 
library can be improved, particularly computing matching subscriptions for a set of tags.
* Injest legacy logging messages - Most systems will have legacy libraries that
     use one of the Java logging systems.  Create some namespaces that
     allow for injecting these log messages into clj-probe middleware.  Ignore
     any that we inject using the log sink.  This may be non-trivial.
* Adapt the function probes to collect profile information

   	 